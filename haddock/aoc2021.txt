-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/ephemient/aoc2021/blob/main/hs/README.md</a>
@package aoc2021
@version 0.1.0.0

module Common

-- | Chinese remainder theorem.
--   
--   <pre>
--   crt (r1, q1) (r2, q2) == (r3, q3) ==&gt;
--   </pre>
--   
--   r3 <a>mod</a> q1 == r1 &amp;&amp; q3 <a>mod</a> q1 == 0 &amp;&amp; r3
--   <a>mod</a> q2 == r2 &amp;&amp; q3 <a>mod</a> q2 == 0
crt :: Integral a => (a, a) -> (a, a) -> (a, a)

-- | Extended GCD.
--   
--   <pre>
--   gcd a b == (s, t, g) ==&gt; a * s + b * t == g
--   </pre>
egcd :: Integral a => a -> a -> (a, a, a)
readEntire :: Reader a -> Text -> Either String a


module Day1
day1a :: Text -> Either String Int
day1b :: Text -> Either String Int


module Day10
day10a :: Text -> Int
day10b :: Text -> Maybe Int


module Day11
step :: (Num a, Ord a, Unbox a) => Int -> Vector a -> Maybe (Int, Vector a)
day11 :: Text -> Maybe (Int, Int)


module Day12
parse :: Graph gr => Text -> Maybe (Int, Int, gr Text Bool)
walk :: (Monad m, Traversable t) => (a -> m (t a)) -> a -> m ()
day12 :: Bool -> Text -> Maybe Int
day12a :: Text -> Maybe Int
day12b :: Text -> Maybe Int


module Day13
parsePair :: (Num a, MonadParsec e s m, Token s ~ Char) => m (a, a)
parseFold :: (Num a, Ord a, MonadParsec e s m, Token s ~ Char, IsString (Tokens s)) => m ((a, a) -> (a, a))
foldX :: (Num a, Ord a) => a -> (a, a) -> (a, a)
foldY :: (Num a, Ord a) => a -> (a, a) -> (a, a)
day13a :: Text -> Either (ParseErrorBundle Text Void) Int
day13b :: Text -> Either (ParseErrorBundle Text Void) [String]


module Day14
day14 :: Text -> Maybe [Int]
day14a :: Text -> Maybe Int
day14b :: Text -> Maybe Int


module Day15
day15 :: Int -> Vector Int -> Maybe Int
day15a :: Text -> Maybe Int
day15b :: Text -> Maybe Int


module Day16
data Packet a
Literal :: Int -> a -> Packet a
[version] :: Packet a -> Int
[value] :: Packet a -> a
Operator :: Int -> Int -> [Packet a] -> Packet a
[version] :: Packet a -> Int
[tag] :: Packet a -> Int
[packets] :: Packet a -> [Packet a]
parser :: (Num a, MonadParsec e s m, Token s ~ Char) => m (Packet a)
day16a :: Text -> Either (ParseErrorBundle Text Void) Int
day16b :: Text -> Either (ParseErrorBundle Text Void) (Maybe Int)


module Day17
parser :: (MonadParsec e s m, IsString (Tokens s), Token s ~ Char, Num a, Ord a) => m ((a, a), (a, a))
day17 :: Text -> Either (ParseErrorBundle Text Void) (Int, Int)


module Day18
data Snailfish a
Snailfish :: Either (Snailfish a) a -> Either (Snailfish a) a -> Snailfish a
data SnailfishToken a
Open :: SnailfishToken a
Close :: SnailfishToken a
Value :: a -> SnailfishToken a
parser :: (MonadParsec e s m, Token s ~ Char, Num a) => m (Snailfish a)
snailfishReduce :: forall a. (Integral a, Ord a) => Snailfish a -> Snailfish a
snailfishAdd :: (Integral a, Ord a) => Snailfish a -> Snailfish a -> Snailfish a
magnitude :: Num a => Snailfish a -> a
day18a :: Text -> Either (ParseErrorBundle Text Void) (Maybe Int)
day18b :: Text -> Either (ParseErrorBundle Text Void) (Maybe Int)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Day18.SnailfishToken a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Day18.SnailfishToken a)


module Day2
data Move a
Horizontal :: a -> Move a
Vertical :: a -> Move a
move :: Integral a => Reader (Move a)
day2a :: Text -> Either String Int
day2b :: Text -> Either String Int


module Day3
common :: Ord a => [a] -> a
uncommon :: Ord a => [a] -> a
day3a :: Text -> Either (ParseErrorBundle String Void) Int
day3b :: Text -> Either (ParseErrorBundle String Void) Int


module Day4
parser :: (MonadParsec e s m, Token s ~ Char) => m ([Int], [[[Int]]])
day4 :: Text -> Either (ParseErrorBundle Text Void) (Maybe (Int, Int))


module Day5
parser :: (Num a, Ord a, MonadParsec e s m, Token s ~ Char, IsString (Tokens s)) => m [((a, a), (a, a))]
intersections :: (Enum a, Integral a, Ord a, Show a) => [((a, a), (a, a))] -> Set (a, a)
day5a :: Text -> Either (ParseErrorBundle Text Void) Int
day5b :: Text -> Either (ParseErrorBundle Text Void) Int


module Day6Meta
newtype Matrix a e
Matrix :: a (Int, Int) e -> Matrix a e
flatten :: (IArray a e, Num e) => Matrix a e -> a Int e
step :: Matrix Array Integer
mkLUT :: QuasiQuoter
instance (Data.Array.Base.IArray a e, GHC.Num.Num e) => GHC.Base.Semigroup (Day6Meta.Matrix a e)


module Day6
day6 :: UArray Int Int -> Text -> Either String Int
day6a :: Text -> Either String Int
day6b :: Text -> Either String Int


module Day7
day7a :: Text -> Either String Int
day7b :: Text -> Either String Int


module Day8
day8a :: Text -> Int
day8b :: Text -> Maybe Int
handle :: Text -> Maybe Int


module Day9
day9a :: Text -> Int
day9b :: Text -> Int
