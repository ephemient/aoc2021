-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/ephemient/aoc2021/blob/main/hs/README.md</a>
@package aoc2021
@version 0.1.0.0

module Common

-- | Chinese remainder theorem.
--   
--   <pre>
--   crt (r1, q1) (r2, q2) == (r3, q3) ==&gt;
--   </pre>
--   
--   r3 <a>mod</a> q1 == r1 &amp;&amp; q3 <a>mod</a> q1 == 0 &amp;&amp; r3
--   <a>mod</a> q2 == r2 &amp;&amp; q3 <a>mod</a> q2 == 0
crt :: Integral a => (a, a) -> (a, a) -> (a, a)

-- | Extended GCD.
--   
--   <pre>
--   gcd a b == (s, t, g) ==&gt; a * s + b * t == g
--   </pre>
egcd :: Integral a => a -> a -> (a, a, a)
readEntire :: Reader a -> Text -> Either String a


module Day1
day1a :: Text -> Either String Int
day1b :: Text -> Either String Int


module Day10
day10a :: Text -> Int
day10b :: Text -> Maybe Int


module Day11
step :: (Num a, Ord a, Unbox a) => Int -> Vector a -> Maybe (Int, Vector a)
day11 :: Text -> Maybe (Int, Int)


module Day12
parse :: Graph gr => Text -> Maybe (Int, Int, gr Text Bool)
walk :: (Monad m, Traversable t) => (a -> m (t a)) -> a -> m ()
day12 :: Bool -> Text -> Maybe Int
day12a :: Text -> Maybe Int
day12b :: Text -> Maybe Int


module Day13
parsePair :: (Num a, MonadParsec e s m, Token s ~ Char) => m (a, a)
parseFold :: (Num a, Ord a, MonadParsec e s m, Token s ~ Char, IsString (Tokens s)) => m ((a, a) -> (a, a))
foldX :: (Num a, Ord a) => a -> (a, a) -> (a, a)
foldY :: (Num a, Ord a) => a -> (a, a) -> (a, a)
day13a :: Text -> Either (ParseErrorBundle Text Void) Int
day13b :: Text -> Either (ParseErrorBundle Text Void) [String]


module Day14
day14 :: Text -> Maybe [Int]
day14a :: Text -> Maybe Int
day14b :: Text -> Maybe Int


module Day15
day15 :: Int -> Vector Int -> Maybe Int
day15a :: Text -> Maybe Int
day15b :: Text -> Maybe Int


module Day16
data Packet a
Literal :: Int -> a -> Packet a
[version] :: Packet a -> Int
[value] :: Packet a -> a
Operator :: Int -> Int -> [Packet a] -> Packet a
[version] :: Packet a -> Int
[tag] :: Packet a -> Int
[packets] :: Packet a -> [Packet a]
parser :: (Num a, MonadParsec e s m, Token s ~ Char) => m (Packet a)
day16a :: Text -> Either (ParseErrorBundle Text Void) Int
day16b :: Text -> Either (ParseErrorBundle Text Void) (Maybe Int)


module Day17
parser :: (MonadParsec e s m, IsString (Tokens s), Token s ~ Char, Num a, Ord a) => m ((a, a), (a, a))
day17 :: Text -> Either (ParseErrorBundle Text Void) (Int, Int)


module Day18
data Token a
Open :: Token a
Close :: Token a
Value :: a -> Token a
parser :: (MonadParsec e s m, Token s ~ Char, Num a) => m [Token a]
add :: (Integral a, Ord a) => [Token a] -> [Token a] -> [Token a]
magnitude :: Num a => [Token a] -> Maybe a
day18a :: Text -> Either (ParseErrorBundle Text Void) (Maybe Int)
day18b :: Text -> Either (ParseErrorBundle Text Void) (Maybe Int)


module Day19
parser :: (MonadParsec e s m, IsString (Tokens s), Token s ~ Char, Num a) => m [[[a]]]
allTransforms :: Int -> [[(Bool, Int)]]
applyTransform :: Num a => [(Bool, Int)] -> [a] -> [a]
day19 :: Text -> Either (ParseErrorBundle Text Void) (Maybe (Int, Int))


module Day2
data Move a
Horizontal :: a -> Move a
Vertical :: a -> Move a
move :: Integral a => Reader (Move a)
day2a :: Text -> Either String Int
day2b :: Text -> Either String Int


module Day20
day20 :: Text -> Maybe [Maybe Int]
day20a :: Text -> Maybe Int
day20b :: Text -> Maybe Int


module Day21
parser :: (MonadParsec e s m, IsString (Tokens s), Token s ~ Char) => m (Int, Int)
day21a :: Text -> Either (ParseErrorBundle Text Void) Int
day21b :: Text -> Either (ParseErrorBundle Text Void) Int


module Day22
parser :: (MonadParsec e s m, IsString (Tokens s), Token s ~ Char, Num a) => m (Bool, ((a, a), (a, a), (a, a)))
day22 :: (Ix a, Num a) => Bool -> [(Bool, ((a, a), (a, a), (a, a)))] -> Int
day22a :: Text -> Either (ParseErrorBundle Text Void) Int
day22b :: Text -> Either (ParseErrorBundle Text Void) Int


module Day23
data Cell a
Cell :: Int -> [a] -> Cell a
[cellDepth] :: Cell a -> Int
[cellStack] :: Cell a -> [a]
parser :: (MonadParsec e s m, Token s ~ Char) => m [Cell Char]
day23a :: Text -> Either (ParseErrorBundle Text Void) (Maybe Int)
day23b :: Text -> Either (ParseErrorBundle Text Void) (Maybe Int)
solve :: (Alternative f, IArray arr (Cell a), Ord (arr Int (Cell a)), Eq a) => (a -> Int) -> IntMap a -> Map (arr Int (Cell a)) Int -> MinPrioHeap Int (arr Int (Cell a)) -> f Int
instance GHC.Classes.Ord a => GHC.Classes.Ord (Day23.Cell a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Day23.Cell a)


module Day24
data Register
W :: Register
X :: Register
Y :: Register
Z :: Register
data Instruction a b
Inp :: a -> Instruction a b
Add :: a -> Either a b -> Instruction a b
Mul :: a -> Either a b -> Instruction a b
Div :: a -> Either a b -> Instruction a b
Mod :: a -> Either a b -> Instruction a b
Eql :: a -> Either a b -> Instruction a b
data State a
State :: !a -> !a -> !a -> !a -> State a
[w] :: State a -> !a
[x] :: State a -> !a
[y] :: State a -> !a
[z] :: State a -> !a
get :: State a -> Register -> a
set :: State a -> Register -> a -> State a
parser :: (MonadParsec e s m, IsString (Tokens s), Token s ~ Char, Num a) => m (Instruction Register a)
run :: Integral a => [a] -> a -> [Instruction Register a] -> State a -> Maybe a
runRange :: Integral a => (a, a) -> [Instruction Register (a, a)] -> State (a, a) -> Bool
day24 :: Text -> Either (ParseErrorBundle Text Void) (Maybe (Integer, Integer))
instance GHC.Base.Functor (Day24.Instruction a)
instance GHC.Base.Functor Day24.State


module Day25
day25 :: Text -> Maybe Int


module Day3
common :: Ord a => [a] -> a
uncommon :: Ord a => [a] -> a
day3a :: Text -> Either (ParseErrorBundle String Void) Int
day3b :: Text -> Either (ParseErrorBundle String Void) Int


module Day4
parser :: (MonadParsec e s m, Token s ~ Char) => m ([Int], [[[Int]]])
day4 :: Text -> Either (ParseErrorBundle Text Void) (Maybe (Int, Int))


module Day5
parser :: (Num a, Ord a, MonadParsec e s m, Token s ~ Char, IsString (Tokens s)) => m [((a, a), (a, a))]
intersections :: (Enum a, Integral a, Ord a, Show a) => [((a, a), (a, a))] -> Set (a, a)
day5a :: Text -> Either (ParseErrorBundle Text Void) Int
day5b :: Text -> Either (ParseErrorBundle Text Void) Int


module Day6Meta
newtype Matrix a e
Matrix :: a (Int, Int) e -> Matrix a e
flatten :: (IArray a e, Num e) => Matrix a e -> a Int e
step :: Matrix Array Integer
mkLUT :: QuasiQuoter
instance (Data.Array.Base.IArray a e, GHC.Num.Num e) => GHC.Base.Semigroup (Day6Meta.Matrix a e)


module Day6
day6 :: UArray Int Int -> Text -> Either String Int
day6a :: Text -> Either String Int
day6b :: Text -> Either String Int


module Day7
day7a :: Text -> Either String Int
day7b :: Text -> Either String Int


module Day8
day8a :: Text -> Int
day8b :: Text -> Maybe Int
handle :: Text -> Maybe Int


module Day9
day9a :: Text -> Int
day9b :: Text -> Int
